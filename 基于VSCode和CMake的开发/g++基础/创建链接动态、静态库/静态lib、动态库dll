0. 一般编译时，实际编译器默认为动态库编译；从动态库和静态库创建+链接，可以知道，只要将库和头文件放入默认文件夹中，编译器就能找到目标，并加入链接文件中【官方库自动检索，自定义库必须-l自己指定】
0.1. 不要忘记头文件的编译，编译时可以将头文件加入编译/将头文件所在目录告诉编译器-I会自动检索
1. 简单的项目编译
	g++ main.cpp ./src/Swap.cpp -I./include -o main
	ps:编译时，无论是缺少include文件，还是缺少Swap.cpp的编译，都会报错，因此，编译时必须一起编译生成可执行文件，而不可以分开编译生成
2. 静态库创建
	g++ -c Swap.cpp -I../include -o Swap.o【可以多个文件合一个库】
		函数定义文件，引入头文件声明，相当于形成文件间向量关系【便于文件间调用】【实现了调用的分离化】
	ar cvsr libSwap.a Swap.o
		ar为归档器，生成静态库【打包】
			r 替换归档文件中已有的文件或加入新文件 (必要)
			c 不在必须创建库的时候给出警告
			s 创建归档索引
			v 输出详细信息
		静态库必须以lib开头，.a结尾
静态库创建成功
3. 静态库链接
	g++ main.cpp -I./include -L./src -lSwap -static -o static_main
		-static 指定使用静态库；一般默认为动态库
		-I./include【指明文件间调用关系】
		-L./src -lSwap -static【指明文件的实际存在形式】
4. 动态库创建
	g++ -shared -fPIC -o libSwap.so Swap.cpp -I../include【可以多个文件合一个库】
		-shared 指明为动态库
		-fPIC 全称是 Position Independent Code， 使用-fPIC选项生成的动态库，是位置无关的。这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量/函数的地址。
	动态库必须以lib开头，.so结尾
5. 动态库链接
	g++ main.cpp -Iinclude -Lsrc -lSwap -o dynamic_main -Wl,-rpath='./src'
		-Wl代表后面的这个参数是一个链接器参数
		-rpath+库所在的目录，会给程序明确指定去哪里找对应的库
		ps：动态库第一次，是将库内数据地址写入可执行文件，由于动态库在运行时才会被加载进内存，还需要库的实际地址，做调用使用
		
