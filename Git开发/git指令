仓库版本管理：git
	git是对文件仓库进行版本管理的语言，在git管理本地仓库的基础上，还有github网站供网上版本管理使用

git版本管理的原理
	git将区域分为：工作区、暂存区、版本区
		.git内为版本库【分为暂存区+版本区】，外为工作区
		工作区：当前文件状态
		暂存区：文件被add后进入暂存区，暂存起来【可以add ./add 单独文件】
		版本区：多个版本串联、分支【与VMWare的快照类似】；
		版本区工作原理：
			A->B,A版本是一个状态
				当B版本为静态时，B版本就是一个状态记录
				B版本为动态时，B版本记录的是在A版本状态后发生的哪些改动信息
			HEAD是头状态的指针【未加入版本的动态状态，是不被HEAD所指向的】
				HEAD^^^代表头状态的前第3个版本
				HEAD~3也代表当前状态的前面第三个版本
1. git的仓库创建
	创建本地仓库：git init 生成.git文件，是git版本管理的基础文件
	克隆外网仓库：git clone + HTTP... ，下载别人的仓库内容到本地浏览
2. 基本指令：
		git add 加入文件到暂存区
		git commit -m '说明' 提交暂存区内容到版本区形成当前版本，并注释
		git log 查看版本信息	，只显示HEAD之前的版本信息
			git log --pretty=oneline --graph【简短输出版本信息，并加分支图】
		git reflog 查看所有的提交和reset信息【HEAD移动信息】，返回值为版本的Identity
		git reset 回退HEAD指针到一个具体状态，修改工作区状态
			<版本回退>
			--hard 只是单纯移动HEAD指针，不会真的删除路径上其他的版本节点
				HEAD前移：eg: git reset --hard HEAD^  回退到上一个状态
					【一个很有意思的点，HEAD代表当前状态,^^^代表之前的状态，
						相当于用文字方式描述了链表的状态】
				HEAD后移：回到以前的节点：使用git reflog 查看之前的版本身份号，
					使用git reset --hard 身份号 前进 
					git reflog git reset --hard 身份号
		git status 查看在工作区、暂存区中文件相比于版本区的对比状态
		git checkout -- 文件名 删除工作区中该文件的改动
		git reset HEAD 文件名 删除存入暂存区中的文件改动，不影响工作区文件
			如果再提交新的该文件改动到暂存区，则覆盖暂存区中原文件的改动信息
		git diff 版本 -- 文件 / 版本1 版本2 -- 文件名
			<文件差异对比>
			git diff HEAD -- code.txt 对比最近的版本状态和code文件的差异对比
			git HEAD HEAD^ -- code.txt 对比最近版本和前一个版本的code文件差异
				diff中+++/---代表的是那个版本文件本身的名字【注意看注释】
			【改动信息/记录上个版本基础上修改的信息 == 版本管理】
		git rm 文件名 移除文件【移除工作区文件，并将信息加入暂存区】
			<删除文件有序>
			rm A , git add A ，等效
			恢复删除文件，需要先删除暂存区改动，再删除工作区改动【顺序不能变】
				先git reset HEAD 文件,git checkout -- 文件
3. 分支介绍：
	HEAD的实质是，HEAD->master；HEAD只有一个且指向当前操作分支，分支可以有多个执行不同的时间线任务，一般master作为主分支供用户使用；【HEAD就像是operator自己，但又不完全是】【HEAD、分支的本质都是'指针'】
	分支的优点：在git版本管理的基础上，实现类似并行开发的功能，许多的人代表着许多的处理器，大家执行不同的如，运维、游戏、测试等不同的任务，在不同的文件夹中，自己的任务分支内可以回溯版本，多任务后由于不同的分支不同的文件，修改信息可以实现合并，实现任务并行;【同一分支内实现版本管理，多分支一起实现任务并行】
	任务合并完，再删除分支，就彻底实现了工程上的工程开发应用
4. 分支指令：
	git branch 分支名，创建分支
		git branch -v 查看所有分支和HEAD指向的分支
		git branch -d 分支名 删除分支！！！【不是删除版本】
	git checkout 分支名 ,切换HEAD需要操控的分支
		git checkout -b 分支名 创建并切换分支
	git merge 目标分支名，将HEAD操作的分支与目标分支进行合并【默认为快速合并】
		合并 == 合并分支文件修改内容 + 提交生成新版本
		<快速合并>:分支在一条线上
			快速合并原理：文件的无二义性修改，显然可以直接合并两个分支【实际就是分支的移动】
		<禁止快速合并，强制正常合并>
			保留分支，做其他处理【修复bug等，让分支突兀出来，便于查看】
				git merge 分支名 --no-ff -m '禁止快速合并'
		<正常分支合并>:不同线上分支合并
			不适用快速合并，按照合并的原理，将分支的文件合并后提交合并入一个新版本
			git merge dev -m '正常合并'
		<分支合并冲突>:不同线上分支合并
			冲突原因：不同分支对'同一文件'进行不同修改
			原理：比如A对文件1写了A，B对文件1写了B，合并文件时不知道以谁为标准【二义性】
			解决：
				冲突时，书写状态实际处于实现merge和前一版本状态的中间状态，这个状态既不能回退也不能前进，只有operator手动修改了冲突文件内容后，并实现提交才进入正常状态；【此时，没有任何回退前进选择，并且已合并文件已处于暂存区中，因此此状态下，只能修复冲突然后提交进入合并状态】
				可以用git status来查看冲突所在文件，文件中会同时给出不同分支在同一文件中的不同改动；operator此时只需要按照这些提示，自己修改就好【怎么修都可以】
		PS：注意分支合并后，分支的移动问题【HEAD控制的那个分支移动，其他分支不动】
			解决后，注意另一个分支的位置，并没有一起更改，要么
				git branch -d/-D 分支,然后再在新合并地方重新创建一个分支
				git merge 合并后那个分支的名字，直接快速合并过去
	git stash 保存工作现场
		<虚拟保存工作环境>
		背景：一般只有在commit书写状态，生成提交版本后，书写的内容才被正式存入维护，但是当书写状态还不能被提交，但是又不得不去其他版本进行修改任务时，如果切换版本，就会导致书写状态信息丢失，此时就需要使用git stash存储工作现场，相当于创建了一个虚拟的'commit'
		git stash pop 在对应分支的对应位置使用，恢复工作环境【工作现场保存在对应节点版本节点的栈中，只要在对应节点位置，就能恢复工作现场，无论是否同一个分支，但是一般都正常使用】
		
5. github上传仓库初始任务
	创建仓库
		public，则别人clone你的仓库不需要密码
		private，则任何人clone仓库都需要密码，除非添加主机公钥
	获取本地OS机器SSH公钥，添加入github账号【以后clone、...都用ssh版本，不用密码等】
	
6. github远程管理仓库指令
	git remote 远程库操作
		git remote -v 查看远程库别名
		git remote rm 别名 移除
		git remote add 别名 远程地址
	git branch --set-upstream-to=origin/分支名 分支名 同名分支的跟踪对比
	git push 远程地址/别名 分支名，推送本地库进远程
	git pull 远程地址/别名 分支名，将远程库拉入本地
	测试0：github上修改的数据信息，是否会记录在github库的.git中？
		答：本地的.git和github的.git分别代表不同的两个版本树，因此都会记录所在版本文件的修改情况
	测试1：github上远程库pull到本地库的的同名分支合并？合并后分支的指向？
		答：github上的版本树和本地的版本树，可以理解为是两个不同的版本树和两个不同的分支== '同名分支';如果进行不同的分支变化，就会出现多个同名不同指向的分支位置；
			<pull、push情况分析>
				对于fast forward的合并方式，无论是pull/push，同名分支都可以合并，并且以最远版本为最终分支指向
				其余所有合并方式，push到github都会失败，必须先pull到本地后手动合并，合并后分支指向新版本的节点
	测试2：github上不同分支显示的版本是什么？
		答：是当前分支所指向的版本数据
	测试3：github上分支版本内显示的commits提交记录是什么？
		答：是这个分支自己的git log，git log显示的原理是，只会显示分支的当前节点->树根所有与这个节点有关的版本信息【在分支图中，只会显示与这条路径有关的分支】【反向递归】
	测试4：如果在树根处再开一个分支，那么他的git log图是什么样的？
		答：如果是线性的版本信息，那么根据'反向递归'，则实际只有一条版本线
	测试5：如果dev分支突然指向其他树杈的版本，那么github内版本和分支信息会如何变化？此时git status是否干净？上传分支状态后，github和本地的同名分支会如何合并？
		答：dev分支显示当前指向的版本信息，github内的分支信息依然依据'反向递归'显示'版本关系图'；由于此时没有书写新的状态因此git status显然很干净；修改分支指向后，上传分支状态无法成功，必须pull远程版本后，手动合并;
	测试6：那么多版本不删除，难道不会乱吗？
		答：产生非常多的版本，只将有用的版本与master主版本汇总，根据反向递归的版本依赖关系，其他无用版本会自动'忽略'

	


















